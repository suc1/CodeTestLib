# [力扣加加](https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/)

## 几种最优化方法
1. 梯度下降法（Gradient Descent）: 随机梯度下降法和批量梯度下降法
2. 牛顿法( Newton s method ): 切线法, 线性优化, 求解复杂的Hessian矩阵的逆矩阵
3. 拟牛顿法（Quasi-Newton Methods）: 非线性优化, 正定矩阵. 常用的拟牛顿法有DFP算法和BFGS算法
4. 共轭梯度法（Conjugate Gradient）
5. 启发式优化方法: 包括经典的模拟退火方法、遗传算法、蚁群算法以及粒子群算法, 多目标优化算法(NSGAII算法、MOEA/D算法以及人工免疫算法)

## 机器人定位技术
1. 超声波: 成本低廉、采集信息速率快、距离分辨率高
2. 视觉导航
3. GPS: 定位精度比较低、可靠性不高
4. 光反射导航: 激光 / 红外传感器, 角度分辨率高，而距离分辨率低
5. SLAM技术: VSLAM(视觉): 计算量太大; Wifi－SLAM(手机中的多种传感设备); Lidar-SLAM: 成本昂贵

## 计算机视觉中的传统特征提取方法
1. 局部特征应该具有的特点： 可重复性、可区分性、准确性、有效性（特征的数量、特征提取的效率）、鲁棒性（稳定性、不变性）
1. SIFT（尺度不变特征变换）: 角点、边缘点、暗区的亮点及亮区的暗点等. SURF, CSIFT
2. HOG（方向梯度直方图）: 人体检测
3. SIFT和HOG的比较: SIFT对于复杂环境下物体的特征提取具有良好的特性；而HOG对于刚性物体的特征提取具有良好的特性
4. SIFT/HOG与神经网络特征提取的比较
5. SURF: 对SITF算子改进
6. ORB: 实时性特征检测: FAST角点检测, BRIEF描述
7. LBP(Local Binary Pattern)(经典LBP, 圆形LBP): 人脸识别、表情识别、行人检测. 
8. HAAR: 人脸检测

## 计算深度
1. [深度图](https://blog.csdn.net/qq_41112170/article/details/126736305)
2. StereoBM_create(), StereoBM.compute(), StereoSGBM_create()

## [初学者」的刷题路径](https://www.zhihu.com/question/278552967/answer/3012342587)
### 数组篇 - 数组的改变、移动
1. 453. 最小移动次数使数组元素相等
2. 665. 非递减数列
3. 283. 移动零
### 数组篇 - 数组的旋转
1. 189. 旋转数组
2. 396. 旋转函数
### 统计数组中的元素
1. 645. 错误的集合
2. 697. 数组的度
3. 448. 找到所有数组中消失的数字
4. 442. 数组中重复的数据
5. 41. 缺失的第一个正数

## [LeetCode 高频题](https://www.algomooc.com/1659.html)

## [算法通关手册（LeetCode](https://algo.itcharge.cn/)

## 概念
1. std::to_string()
2. std::stringstream
3. sprintf()
3. boost::lexical_cast
4. [单调栈-正／倒三角形](https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/): 求解出某个元素左边或者右边第一个比它大或者小的元素
5. [状压 DP](https://mp.weixin.qq.com/s/ecxTTrRvUJbdWwSFbKgDiw)
6. 空间换时间: 哈希表， 前缀树
7. 线性结构(1前驱,1后继): 数组，栈，链表
8. 非线性结构: 树，图等
9. 递归的解法 = 用循环+栈的解法
10. 树的基本算法: 前中后序遍历, 层次遍历
11. 二叉树: 原理[孩子 + 兄弟法](http://data.biancheng.net/view/30.html)
12. 堆其实是一种优先级队列, 一种典型的实现就是二叉堆, 求最小值或者第 k 小的值
13. 二叉查找树中序遍历的结果是一个有序数组
14. 二叉平衡树, 排序数组的二分法查找一样
15. AVL自平衡二叉查找树
16. 红黑树: 对称二叉 B 树
17. 字典树（前缀树）,  Trie 树


## 略过问题:
1. 1
2. 21

## 第一章 - 算法专题: 链表
1. 链表是一种递归的数据结构: 一个原则(画图)， 两种题型(指针的修改, 链表的拼接)，三个注意(环, 边界, 递归)，四个技巧(虚拟头, 快慢指针, 拼接链表, 先修改指针再排序后判空)
2. 翻转一个子链表，并返回新的头与尾: `prev=nullptr; cur=head;`, cur从head开始
3. 虚拟头的作用: 1. 将头节点变成中间节点, 2. 通过在合适的时候断开链接，返回链表的中间节点
4. 快慢指针: 获取中间项和倒数第几项等特定元素
5. 一开始`tail=head`，后面相等就是没重复，不等就是有重复: 82. Remove Duplicates from Sorted List II
6. [循环链表的起点](https://zhuanlan.zhihu.com/p/481583461) 

## 第一章 - 算法专题: 树. (树的题目，基本都是考察递归思想的)
1. 方法: 一个中心(遍历:递归DFS，队列BFS)，两个基本点(DFS:递归 + 栈迭代, BFS:带层/不带层的队列)，三种题型[搜索类(开始点，结束点, 目标)，构建类(普通二叉树的构建, 二叉搜索树的构建), 修改类]，四个重要概念, 七个技巧
2. 四个重要概念: 二叉搜索树，
3. 七个技巧
2. 二叉树的存储: 链表, 数组
3. 双色标记法-类似递归: 用迭代统一三种遍历树, 压栈是元组, 颜色是访问／输出否(第一次进入栈, 递归返回)
4. DFS 细分为前中后序遍历, 适合找到一个可行方案
5. BFS 细分为带层的和不带层的, 适合找到最佳方案, 求最短问题时候可以提前终止
6. 层次遍历和 BFS 是完全不一样的东西
7. DFS遍历看的是主逻辑的位置
8. BFS带层信息: 记忆批次的顺序，一次循环(栈中元素个数)处理完此批次，批次的顺序+1
9. `int dfs(root, path, ...)`
10. 入口是任意节点的题目，使用双递归来完成
11. 交错类的题目: (1)使用 -1 和 1 来记录方向，乘以 -1. (2) 0, 1 XOR. (3) true/false取反
12. 树的结构对于动态数据比较友好. 普通二叉搜索树增删是 O(h). 平衡二叉搜索树是 O(logN). 数组是 O(N)
13. 方便搜索，是二叉搜索树核心的设计初衷。不让查找算法时间复杂度退化到线性是平衡二叉树的初衷
13. 二分的本质是将问题规模缩小到一半: 跳表就是链表的二分，二叉搜索树就是树的二分
14. 二叉搜索树的中序遍历的结果是一个有序数组
15.  98. 验证二叉搜索树 就可以直接中序遍历，并一边遍历一边判断遍历结果是否是单调递增的，如果不是则提前返回 False 即可。
16. 在完全二叉树中，除了最后一层，其他层的节点都是满的.
17. 满二叉树的节点数量始终是2的幂次方
18. 在完全二叉树中, 从0编号，父节点是i，左子是2*i+1，右子是2*i+2
19. 在完全二叉树中, 从1编号，父节点是i，左子是2*i，右子是2*i+1, 父节点就是 i/2
20. 路径: 子树的路径和计算出来了，可以推导出父节点的最大路径和. 但是子树最大路径有可能没直连根，怎么处理???????
21. 距离: 最短路径就是距离，而树的最短路径就是边的数目
22. [863. 二叉树中所有距离为 K 的结点](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/)
23. 七个技巧: 全部是基于 dfs. 
    23.1. `def dfs(root)`
    23.2. `单/双递归`
    23.3. 前后遍历: 链表只有一个 next 指针，因此只有两种遍历。而二叉树有两个指针，因此常见的遍历有三个
    23.4. 前后序对于树来说，其实是自顶向下或者自底向上. 自底向上通常用后序遍历
    23.5. 如果你能使用参数和节点本身的值来决定什么应该是传递给它子节点的参数，那就用前序遍历。
    23.6. 如果对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出当前节点的答案，那就用后序遍历。
    23.7. 如果遇到二叉搜索树则考虑中序遍历
    23.8. 虚拟节点: 链表的头会被修改, 需要返回树中间的某个节点（不是返回根节点）
    23.9. 搜索类边界: 空节点, 叶子节点
    23.10. 构建类边界: 参数扩展的边界, 虚拟节点
    23.11. 参数扩展大法: 携带父亲的信息; 携带路径信息; 二叉搜索`dfs(root, minV, maxV)`; 返回元组/数组
    23.12. dfs 返回数组比较少见. 只有用到笛卡尔积的时候，考虑使用返回数组的方式: ”所有可能“，”所有情况“
24. 树，首先考虑递归
    24.1 543: 二叉树的直径. 函数返回以该节点为子树的节点个数, 一条路径; 题目要求返回两条路径
    24.2 ToDo: 987. 二叉树的垂序遍历: 双向数组没有现成方法，替代解决: 排序(col, row, value)，map(col -> (row, value))
    24.3 四个重要概念: *完全二叉树，二叉搜索树，路径和距离*

## 第一章 - 算法专题: 堆专题（上）
1. 虚拟时间: 优先级转成提前时间
2. 优先级队列: 跳表, 二叉堆, 红黑树



## 第四章 - 高频考题（简单）
1. 面试题 17.12. BiNode: 中序遍历
2. 0026. 删除排序数组中的重复项: 双指针-效率最高
3. 0160. 相交链表: a到达尾部,重定位B头 -效率最高
4. 0088. 合并两个有序数组: 要求原地修改-从尾归并排序
5. 0101. 对称二叉树: 关键是4个节点的对称, `return subTree(left->left, right->right) && subTree(left->right, right->left)`
6. 0121. 买卖股票的最佳时机: 碰到比当前小的，更新下限; 碰到比当前大的，更新上限-利润
7. 0155. 最小栈: 两个栈-最小值形成栈
8. 0167. 两数之和 II 输入有序数组: 双指针
9. 0169. 多数元素: [多数投票算法](https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95)
10. 0172. 阶乘后的零: 因数分解之后发现 5 的个数远小于 2. 归纳方程：`f(n) = n / 5 + n / 25 + n / 125 + ... + n / 5^k`
11. 0190. 颠倒二进制位: 一共32位，但是移动只是31位
12. 0191. 位 1 的个数: n & (n - 1) 可以消除 n 最后的一个 1 的原理
13. 0198. 打家劫舍: 对于第[i] 个房子，我们抢还是不抢
14. 0206. 反转链表: 每次只考虑处理一个节点。 链表分三个部分:prev, cur, next
15. 0232. 用栈实现队列: 为了在多进程中分开对同一个队列对读写操作
16. 0263. 丑数: 注意 n =0
17. 0283. 移动零: 双指针, 但是没想到快慢双指针
18. 0342. 4 的幂: `return (n&(n-1))==0 && (n%3==1)`
19. 0371. 两整数之和: 异或看成是一种不进位的加减法, 与的结果左移1位表示进位
20. 401. 二进制手表: 笛卡尔积=两层循环; n个1，怎样[递归枚举](https://blog.csdn.net/qq_44965626/article/details/107258129)
21. 0437. 路径总和 III: 
22. 0665. 非递减数列: 递减对, 但是没想到替换
23. 0661. 图片平滑器: 以当前点为圆心，而不是为边; 二维数组，最里面是X轴
24. 821. 字符的最短距离: 分三种区间超时-编译器缺陷？; 单调栈-双向变成两个单向
25. 0874. 模拟行走机器人: 查找障碍物-走一步查一步，避免复杂的运算. tuple
26. 1128. 等价多米诺骨牌对的数量: 组合计数
27. 1332. 删除回文子序列: 子序列<->子串
28. 2591. 将钱分给最多的儿童: 贪心+脑筋急转弯
29. 662. 二叉树最大宽度: 因为算宽度按节点不好计算，按编号好计算; 